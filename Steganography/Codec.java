/**Name: Naomi Maranga
  * PennKey: kmaranga
  * Recitation: 204
  * Execution: java Codec 
  * Description: A library that has methods that encode and decode a message, 
  *              encrypt and also decrypt the message by converting the chars in 
  *              the message(type String) into their binary representation and 
  *              then XORing respective least significant bits with random bits 
  *              generated by a shift register to encrypt the message. 
  */

public class Codec {
    /** Input:       takes in a String str
      * Output:      returns an integer array 
      * Description: takes in a String str and returns an integer array where 
      *              each element is a single bit in the ASCII encoding of the 
      *              String. 
      */
    public static int[] encode(String str) {
        if (str == null) {
            return null;
            
        } 
        int[] encode1 = new int[str.length() * 7];
        //loop through the chars in a string
        for (int i = 0; i < str.length(); i++) {
            if ((int) str.charAt(i) > 127) {
                throw new RuntimeException("ERROR: Attempting to use a char" +
                                                " with unicode value > 127");
            }
            else {
                int[] binary = charToIntArray(str.charAt(i));
                //convert the charAt(i) to to binary representation
                for (int k = 0; k < 7; k++) {
                    //populate the big array with bits/ rem to check at what 
                    //element of the array you stopped and then add after that
                    encode1[k + i * 7] = binary[k];
                  
                }
            }  
        }
        return encode1; 
    }
    
    /* Input:       takes in an integer array of bits
     * Output:      returns a decoded string
     * Description: takes in an integer array of bits, where each 7 bits 
     *              represent a char in a string(word) and converts these bits
     *              into chars which are concatenated into a string - the 
     *              decoded string
     */
    public static String decode(int[] bits) {
        
        if (bits == null) {
            return null;
        }
        if (bits.length % 7 != 0) {
            throw new RuntimeException("ERROR:Attempting to use array whose" +
                                           " length is not a multiple of 7");
        }
        String decodedString = "";
        for (int i = 0; i < bits.length; i++) {
            if (bits[i] != 0 && bits[i] != 1) {
                throw new RuntimeException("ERROR:Trying to use non-binary" + 
                                                " bits in message");
                
            }
        } 
        //accept an array of ints and return the decoded string
        int[] temp = new int[7];
        for (int l = 0; l < bits.length / 7; l++) {
            for (int k = 0; k < 7; k++) {
                temp[k] =  bits[l * 7 + k]; //still index out of bounds array 
         
                //System.out.println(decodedString); 
            }
            decodedString += intArrayToChar(temp); //concatenate chars 
            
        }
        
        return decodedString;  
    }
    
    
    /* Input:       an integer array containing bits that represent chars in the
     *              message(string that we want to encrypt)
     * Output:      an encryted message i.e a sequence of encrypted bits made by 
     *              XOR-ing the message bits by random bits made by the LFSR
     * Description: encrypts a message by XOR-ing the message with a sequence of
     *              pseudo-random bits generated by the LFSR, with the password
     *              being the LFSR's seed and tapPosition. Throws exceptions if 
     *              user tries to use impossible conditions. 
     * 
     */
    public static void encrypt(int[] message, String seed, int tapPosition) {
        LFSR lfsr = new LFSR(seed, tapPosition); //make a new LFSR object 
        //Error checks 
        if (message == null) {
            return; //do nothing
        }
        if (seed == null) {
            throw new RuntimeException("ERROR: Attempting to access/perform" +
                                            "operations on a null seed"); 
        }
        if (tapPosition < 0 || tapPosition > seed.length()) {
            throw new RuntimeException("ERROR: tapPosition index is out" +
                                            "of bounds");
        }
        for (int i = 0; i < seed.length(); i++) {
            if (seed.charAt(i) != '0' && seed.charAt(i) != '1') {
                throw new RuntimeException("ERROR: Trying to use non-binary" +
                                                " bits/characters in seed");
            }
        }
        if (message.length % 7 != 0) {
            throw new RuntimeException("ERROR: Attempting to use a" +
                                            " message whose length is not a" +
                                            " multiple of 7"); 
        }
        for (int i = 0; i < message.length; i++) {
            if (message[i] != 0 && message[i] != 1) {
                throw new RuntimeException("ERROR: Trying to use non-binary" +
                                                "bits in message array");
            } else {
                //perform encryption
                int nextBit = lfsr.nextBit();
                message[i] = message[i] ^ nextBit; 
            }
        }
       
    }
    
    /* Input:       takes in an integer array cipher, a String seed and an 
     *              integer tapPosition
     * Output:      Returns a decrypted String 
     * Description: takes in an encrypted array and employs the symmetry of the 
     *              XOR operation to decrypt the message. 
     */
    public static void decrypt(int[] cipher, String seed, int tapPosition) {
        //ONE LINE LONG! 
        encrypt(cipher, seed, tapPosition);
    }
    
    /* Input:       a char ch to be typecast into an int
     * Output:      binary representation of a char's ASCII value as an integer
     *              array where each element is a single bit, using 7 bits
     * Description: a helper function that converts a character into a binary 
     *              representation of its ASCII value 
     */
    private static int[] charToIntArray(char ch) {
        int[] charToIntArray = new int[7]; //make arr size 7, bits no. in binary
        int decimal = (int) ch; //typecast char into int
        //change decimal into binary representation
        int index = charToIntArray.length - 1; //right to left
        for (int i = decimal; i > 0; i /= 2) {
            int bit = i % 2;
            charToIntArray[index] = bit; 
            index--; 
        }
//        for(int i = 0; i < charToIntArray.length; i++) {
//            System.out.print(charToIntArray[i] + ", ");
//        }
        return charToIntArray; 
    } 
    
    /* Input:       an integer array bitString
     * Output:      a character that matches in value the binary representation
     *              of the elements in the string 
     * Description: takes in an integer array bitString and returns a character
     * 
     */
    private static char intArrayToChar(int[] bitString) {
        int sum = 0; //accumulator variable
        //change binary representation into a decimal 
        int index = bitString.length - 1; 
        for (int i = 0; i < bitString.length; i++) {
            int bitValDecimal = bitString[i] * ((int) Math.pow(2, index));
            index--;
            sum += bitValDecimal; //sum will be my decimal rep.
        }
        
        //typecast the decimal into a char and ouput that char i.e print
        char arrayToChar = (char) sum;
        
        return arrayToChar; 
    }
    
    
    /**Input: takes in a String str
      * Output: returns an integer array of the String's characters converted
      *         into binary
      * Description: A helper function that aids in testing my charToIntArray
      *              function to determine whether it's correctly converting the 
      *              characters in my string to their binary representation
      */
    private static int[] stringToBinary(String str) {
        int[] testIntArray = new int[str.length() * 7];
        for (int i = 0; i < str.length(); i++) {
            int[] ascii = charToIntArray(str.charAt(i));
            for (int k = 0; k < ascii.length; k++) {
                testIntArray[i * 7 + k] = ascii[k];
            }
        }
        return testIntArray;
    }
    
    //main method for testing 
    public static void main(String[] args) {
        //  charToIntArray('A');
//        int [] bit = {1, 0, 0, 0, 0, 1, 1};
//        System.out.println(intArrayToChar(bit));
//        
//        //have a message that I want to encrypt
//        int[] testEncrypt = stringToBinary("C");
//        for (int i = 0; i < testEncrypt.length; i++) {
//            System.out.print(testEncrypt[i]);
//        }
//        int[] binary = stringToBinary("C");
//        encrypt(binary, "01101000010", 8);
//        for(int i = 0; i < binary.length; i++) {
//            //   System.out.print(binary[i]);
//        }
//        
//        int[] decode1 =  {1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 
//            1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1};
//        //for(int j = 0; j < decode1.length; j++) {
//        //   System.out.println(decode(decode1));
//        //  }
    }
}

